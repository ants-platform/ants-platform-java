/**
 * Utility class for generating deterministic agent IDs using BLAKE2b.
 *
 * This mirrors the Python SDK implementation to ensure consistent behavior
 * across all ANTS Platform SDKs.
 */
package com.ants.platform.client.core;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.logging.Logger;

/**
 * Generates deterministic agent IDs using BLAKE2b-64 hashing.
 *
 * <p>Formula: {@code agent_id = BLAKE2b-64(agent_name + project_id)}
 *
 * <p>Key Design Decision: Include {@code project_id} in hash for transfer safety
 * <ul>
 *   <li>When projects transfer between organizations, projectId stays constant</li>
 *   <li>organizationId changes, but projectId doesn't</li>
 *   <li>Result: agent_id remains stable across transfers</li>
 * </ul>
 *
 * <p>Properties:
 * <ul>
 *   <li>Deterministic: Same inputs always produce the same agent_id</li>
 *   <li>Collision-resistant: BLAKE2b provides cryptographic guarantees</li>
 *   <li>Compact: 16 hex characters (64 bits of entropy)</li>
 *   <li>Fast: ~1 microsecond per hash</li>
 * </ul>
 *
 * <p>Example:
 * <pre>{@code
 * String agentId = AgentIdGenerator.generateAgentId("qa_agent", "proj-customer-support");
 * // Result: "1fdb77db0603771f" (deterministic 16-char hex)
 * }</pre>
 */
public final class AgentIdGenerator {

    private static final Logger LOGGER = Logger.getLogger(AgentIdGenerator.class.getName());

    /**
     * Length of the generated agent ID in hex characters.
     * BLAKE2b-64 produces 8 bytes = 16 hex characters.
     */
    public static final int AGENT_ID_LENGTH = 16;

    /**
     * Digest size in bytes for BLAKE2b-64.
     */
    private static final int DIGEST_SIZE = 8;

    private AgentIdGenerator() {
        // Utility class, prevent instantiation
    }

    /**
     * Generates a deterministic agent ID using BLAKE2b-64.
     *
     * <p>The agent_id is generated by hashing agent_name followed by project_id.
     * This matches the Python SDK implementation:
     * <pre>
     * hasher = hashlib.blake2b(digest_size=8)
     * hasher.update(agent_name.encode('utf-8'))
     * hasher.update(project_id.encode('utf-8'))
     * agent_id = hasher.hexdigest()
     * </pre>
     *
     * @param agentName the agent name (must be a non-empty string)
     * @param projectId the project ID (must be a non-empty string)
     * @return a 16-character hex string representing the agent ID
     * @throws IllegalArgumentException if any parameter is null or empty
     */
    public static String generateAgentId(String agentName, String projectId) {
        // Validate inputs
        if (agentName == null || !(agentName instanceof String) || agentName.isEmpty()) {
            throw new IllegalArgumentException("agent_name must be a non-empty string");
        }
        if (projectId == null || !(projectId instanceof String) || projectId.isEmpty()) {
            throw new IllegalArgumentException("project_id must be a non-empty string");
        }

        try {
            // Use BLAKE2b with 8-byte digest (64 bits)
            // Java doesn't have native BLAKE2b in standard library before Java 9,
            // but MessageDigest may support it. If not available, we fall back to
            // a compatible implementation.
            MessageDigest digest;
            try {
                // Try to get BLAKE2b-64 (available in some JVMs)
                digest = MessageDigest.getInstance("BLAKE2B-64");
            } catch (NoSuchAlgorithmException e) {
                // Fallback: Use our own BLAKE2b implementation
                return generateAgentIdWithBlake2b(agentName, projectId);
            }

            // Hash agent_name first, then project_id (matching Python SDK order)
            digest.update(agentName.getBytes(StandardCharsets.UTF_8));
            digest.update(projectId.getBytes(StandardCharsets.UTF_8));
            byte[] hashBytes = digest.digest();

            String agentId = bytesToHex(hashBytes);
            LOGGER.info(String.format("[AGENT_ID] Generated: %s from agent_name: %s", agentId, agentName));
            return agentId;

        } catch (Exception e) {
            // Fallback to our implementation
            return generateAgentIdWithBlake2b(agentName, projectId);
        }
    }

    /**
     * Generates agent ID using a pure Java BLAKE2b implementation.
     * This ensures compatibility across all Java versions.
     */
    private static String generateAgentIdWithBlake2b(String agentName, String projectId) {
        Blake2b blake2b = new Blake2b(DIGEST_SIZE);
        blake2b.update(agentName.getBytes(StandardCharsets.UTF_8));
        blake2b.update(projectId.getBytes(StandardCharsets.UTF_8));
        byte[] hash = blake2b.digest();

        String agentId = bytesToHex(hash);
        LOGGER.info(String.format("[AGENT_ID] Generated: %s from agent_name: %s", agentId, agentName));
        return agentId;
    }

    /**
     * Converts a byte array to a hexadecimal string.
     *
     * @param bytes the byte array to convert
     * @return the hexadecimal string representation
     */
    private static String bytesToHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder(2 * bytes.length);
        for (byte b : bytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
        return hexString.toString();
    }

    /**
     * Minimal BLAKE2b implementation for agent ID generation.
     * Based on RFC 7693 - BLAKE2b with 64-bit output.
     */
    private static class Blake2b {
        // BLAKE2b initialization vector
        private static final long[] IV = {
            0x6a09e667f3bcc908L, 0xbb67ae8584caa73bL,
            0x3c6ef372fe94f82bL, 0xa54ff53a5f1d36f1L,
            0x510e527fade682d1L, 0x9b05688c2b3e6c1fL,
            0x1f83d9abfb41bd6bL, 0x5be0cd19137e2179L
        };

        // BLAKE2b sigma schedule
        private static final byte[][] SIGMA = {
            {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
            {14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3},
            {11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4},
            {7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8},
            {9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13},
            {2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9},
            {12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11},
            {13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10},
            {6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5},
            {10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0},
            {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
            {14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3}
        };

        private final int digestLength;
        private final long[] h = new long[8];
        private final long[] t = new long[2];
        private final byte[] buffer = new byte[128];
        private int bufferOffset = 0;

        Blake2b(int digestLength) {
            this.digestLength = digestLength;

            // Initialize state
            System.arraycopy(IV, 0, h, 0, 8);
            // Parameter block: digest length, key length (0), fanout (1), depth (1)
            h[0] ^= 0x01010000L ^ digestLength;
        }

        void update(byte[] data) {
            for (byte b : data) {
                if (bufferOffset == 128) {
                    t[0] += 128;
                    if (t[0] < 128) t[1]++;
                    compress(false);
                    bufferOffset = 0;
                }
                buffer[bufferOffset++] = b;
            }
        }

        byte[] digest() {
            t[0] += bufferOffset;
            if (t[0] < bufferOffset) t[1]++;

            // Pad with zeros
            while (bufferOffset < 128) {
                buffer[bufferOffset++] = 0;
            }

            compress(true);

            // Extract digest
            byte[] result = new byte[digestLength];
            for (int i = 0; i < digestLength; i++) {
                result[i] = (byte) (h[i / 8] >> (8 * (i % 8)));
            }
            return result;
        }

        private void compress(boolean last) {
            long[] v = new long[16];
            long[] m = new long[16];

            // Initialize working vector
            System.arraycopy(h, 0, v, 0, 8);
            System.arraycopy(IV, 0, v, 8, 8);

            v[12] ^= t[0];
            v[13] ^= t[1];

            if (last) {
                v[14] = ~v[14];
            }

            // Convert buffer to message words
            for (int i = 0; i < 16; i++) {
                m[i] = bytesToLong(buffer, i * 8);
            }

            // 12 rounds of mixing
            for (int round = 0; round < 12; round++) {
                byte[] s = SIGMA[round];
                mix(v, m, 0, 4, 8, 12, s[0], s[1]);
                mix(v, m, 1, 5, 9, 13, s[2], s[3]);
                mix(v, m, 2, 6, 10, 14, s[4], s[5]);
                mix(v, m, 3, 7, 11, 15, s[6], s[7]);
                mix(v, m, 0, 5, 10, 15, s[8], s[9]);
                mix(v, m, 1, 6, 11, 12, s[10], s[11]);
                mix(v, m, 2, 7, 8, 13, s[12], s[13]);
                mix(v, m, 3, 4, 9, 14, s[14], s[15]);
            }

            // Finalize
            for (int i = 0; i < 8; i++) {
                h[i] ^= v[i] ^ v[i + 8];
            }
        }

        private static void mix(long[] v, long[] m, int a, int b, int c, int d, int xi, int yi) {
            v[a] = v[a] + v[b] + m[xi];
            v[d] = Long.rotateRight(v[d] ^ v[a], 32);
            v[c] = v[c] + v[d];
            v[b] = Long.rotateRight(v[b] ^ v[c], 24);
            v[a] = v[a] + v[b] + m[yi];
            v[d] = Long.rotateRight(v[d] ^ v[a], 16);
            v[c] = v[c] + v[d];
            v[b] = Long.rotateRight(v[b] ^ v[c], 63);
        }

        private static long bytesToLong(byte[] b, int offset) {
            long result = 0;
            for (int i = 0; i < 8 && offset + i < b.length; i++) {
                result |= (b[offset + i] & 0xFFL) << (8 * i);
            }
            return result;
        }
    }
}
